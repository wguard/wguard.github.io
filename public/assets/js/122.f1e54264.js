(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{586:function(a,t,r){"use strict";r.r(t);var s=r(1),e=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"title"},[a._v("介绍")]),t("p",[a._v("Java线程")])]),t("h3",{attrs:{id:"_1-java线程的创建方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-java线程的创建方式"}},[a._v("#")]),a._v(" "),t("strong",[a._v("1  Java线程的创建方式")])]),a._v(" "),t("p",[a._v("   java线程创建方式有四种：继承Thread类、实现Runnable接口、实现Callable接口、基于线程池。")]),a._v(" "),t("h4",{attrs:{id:"_1-1-继承thread类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-继承thread类"}},[a._v("#")]),a._v(" "),t("strong",[a._v("1.1  继承Thread类")])]),a._v(" "),t("p",[a._v("  Thread类实现了Runnable接口并定义了操作线程的一些方法，我们可以通过继承Thread类的方式创建一个线程。具体实现为创建一个类并继承Thread接口，然后实例化线程对象并调用start方法启动线程。start方法是一个native方法，通过在操作系统上启动一个新线程，并最终执行run方法来启动一个线程。run方法内的代码是线程类的具体实现逻辑。")]),a._v(" "),t("h4",{attrs:{id:"_1-2-实现runnable接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-实现runnable接口"}},[a._v("#")]),a._v(" 1.2 实现Runnable接口")]),a._v(" "),t("h4",{attrs:{id:"_1-3-实现callable接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-实现callable接口"}},[a._v("#")]),a._v(" 1.3 实现Callable接口")]),a._v(" "),t("h4",{attrs:{id:"_1-4-基于线程池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-基于线程池"}},[a._v("#")]),a._v(" 1.4 基于线程池")]),a._v(" "),t("h3",{attrs:{id:"_2-线程的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-线程的生命周期"}},[a._v("#")]),a._v(" "),t("strong",[a._v("2  线程的生命周期")])]),a._v(" "),t("h3",{attrs:{id:"_3-线程的基本方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-线程的基本方法"}},[a._v("#")]),a._v(" "),t("strong",[a._v("3  线程的基本方法")])]),a._v(" "),t("h3",{attrs:{id:"_4-线程池的工作原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-线程池的工作原理"}},[a._v("#")]),a._v(" "),t("strong",[a._v("4  线程池的工作原理")])])])}),[],!1,null,null,null);t.default=e.exports}}]);